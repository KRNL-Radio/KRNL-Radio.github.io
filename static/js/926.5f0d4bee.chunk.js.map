{"version":3,"file":"static/js/926.5f0d4bee.chunk.js","mappings":"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","sources":["../node_modules/decode-named-character-reference/index.dom.js","../node_modules/micromark-core-commonmark/lib/blank-line.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-util-character/index.js","../node_modules/micromark-util-chunked/index.js","../node_modules/micromark-util-classify-character/index.js","../node_modules/micromark-util-combine-extensions/index.js","../node_modules/micromark-util-decode-numeric-character-reference/index.js","../node_modules/micromark-util-decode-string/index.js","../node_modules/micromark-util-normalize-identifier/index.js","../node_modules/micromark-util-resolve-all/index.js","../node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","../node_modules/micromark-extension-gfm-footnote/lib/syntax.js","../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../node_modules/micromark-extension-gfm-table/lib/syntax.js","../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","../node_modules/micromark-extension-gfm/index.js","../node_modules/ccount/index.js","../node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/mdast-util-gfm-autolink-literal/index.js","../node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-gfm-footnote/index.js","../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/mdast-util-gfm-strikethrough/index.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/markdown-table/index.js","../node_modules/mdast-util-gfm-table/lib/index.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-gfm-task-list-item/index.js","../node_modules/mdast-util-gfm/lib/index.js","../node_modules/remark-gfm/index.js","../node_modules/unist-util-is/index.js","../node_modules/unist-util-visit-parents/index.js"],"sourcesContent":["/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string|false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const char = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownSpace} from 'micromark-util-character'\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nexport const unicodePunctuationRegex =\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\n\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexport const asciiDigit = regexCheck(/\\d/)\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\nexport const unicodeWhitespace = regexCheck(/\\s/)\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nfunction regexCheck(regex) {\n  return check\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {number} start\n * @param {number} remove\n * @param {T[]} items\n * @returns {void}\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {unknown[]} */\n\n  let parameters // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0 // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove) // @ts-expect-error Hush, it’s fine.\n    ;[].splice.apply(list, parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0) // @ts-expect-error Hush, it’s fine.\n      ;[].splice.apply(list, parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n\n/**\n * Classify whether a character code represents whitespace, punctuation, or\n * something else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * Note that eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n * @returns {number|undefined}\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = []\n      const value = right[code]\n      constructs(\n        // @ts-expect-error Looks like a list.\n        left[code],\n        Array.isArray(value) ? value : value ? [value] : []\n      )\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {unknown[]} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type]\n      }\n    }\n  }\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.\n    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) || // Noncharacters.\n    (code > 64975 && code < 65008) ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 || // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n\n  return String.fromCharCode(code)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n/**\n * Utility to decode markdown strings (which occur in places such as fenced\n * code info strings, destinations, labels, and titles).\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n * @returns {string}\n */\n\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\n\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  } // Reference.\n\n  const head = $2.charCodeAt(0)\n\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * Normalize an identifier (such as used in definitions).\n *\n * @param {string} value\n * @returns {string}\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value // Collapse Markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n      .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  asciiDigit,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n}\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n/** @type {ConstructRecord} */\n\nconst text = {}\n/** @type {Extension} */\n\nexport const gfmAutolinkLiteral = {\n  text\n}\nlet code = 48 // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\n\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean} */\n\n  let hasDot\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n  /** @type {State} */\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true\n      }\n\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n  /** @type {State} */\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    hasDigitInLastSegment = undefined\n    return label\n  }\n  /** @type {State} */\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n  /** @type {State} */\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww') // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but that’s not how it’s implemented by them).\n\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 72 && code !== 104) ||\n      !previousHttp(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n  /** @type {State} */\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n  /** @type {State} */\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return w2\n  }\n  /** @type {State} */\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment\n  return domain\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n    if (\n      code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0\n  return inPath\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (code === 40) {\n      balance++\n    }\n\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, it’s\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    } // If the punctuation marker is followed by the end of the path, it’s not\n    // continued punctuation.\n\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction trailingPunctuation(code) {\n  return (\n    code === 33 ||\n    code === 34 ||\n    code === 39 ||\n    code === 41 ||\n    code === 42 ||\n    code === 44 ||\n    code === 46 ||\n    code === 58 ||\n    code === 59 ||\n    code === 60 ||\n    code === 63 ||\n    code === 95 ||\n    code === 126\n  )\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code)\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n/** @type {Previous} */\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code)\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @returns {Extension}\n */\n\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n\n  let labelStart // Find an opening.\n\n  while (index--) {\n    const token = self.events[index][1]\n\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    } // Exit if we’ve walked far enough.\n\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token|undefined} */\n\n  let labelStart // Find an opening.\n\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker' // The whole (without `!`):\n\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // The `^` marker\n\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  } // Increment the end 1 character.\n\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n  /** @type {Array<Event>} */\n\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context], // The `[`\n    events[index + 3],\n    events[index + 4], // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context], // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n  /** @type {State} */\n\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n  /** @type {State} */\n\n  function callData(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      effects.exit('chunkString')\n      token = effects.exit('gfmFootnoteCallString')\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token)))\n        ? end(code)\n        : nok(code)\n    }\n\n    effects.consume(code)\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    return code === 92 ? callEscape : callData\n  }\n  /** @type {State} */\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    effects.exit('gfmFootnoteCall')\n    return ok\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n\n  let identifier\n  let size = 0\n  /** @type {boolean|undefined} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelStart\n  }\n  /** @type {State} */\n\n  function labelStart(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      return atBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === null || code === 91 || size > 999) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code)\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      size++\n      return atBreak\n    }\n\n    effects.enter('chunkString').contentType = 'string'\n    return label(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (\n      code === null ||\n      markdownLineEnding(code) ||\n      code === 91 ||\n      code === 93 ||\n      size > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : label\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace')\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier)\n    }\n\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n/** @type {Exiter} */\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfmStrikethrough(options = {}) {\n  let single = options.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1 // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open && // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            } // Opening.\n\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ] // Between.\n\n            splice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            ) // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n    /** @type {State} */\n\n    function more(code) {\n      const before = classifyCharacter(previous)\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, prefixed, 'linePrefix')\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === null ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1] // Indented code can interrupt delimiter and body rows.\n\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === 'linePrefix' &&\n        tail[2].sliceSerialize(tail[1], true).length >= 4\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n  /** @type {State} */\n\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null || // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    // To match how GH works in comments, use `markdownSpace` (`[ \\t]`) instead\n    // of `markdownLineEndingOrSpace` (`[ \\t\\r\\n]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  const self = this\n  return factorySpace(effects, after, 'whitespace')\n  /** @type {State} */\n\n  function after(code) {\n    const tail = self.events[self.events.length - 1]\n    return (\n      // We either found spaces…\n      ((tail && tail[1].type === 'whitespace') || // …or it was followed by a line ending, in which case, there has to be\n        // non-whitespace after that line ending, because otherwise we’d get an\n        // EOF as the content is closed with blank lines.\n        markdownLineEnding(code)) &&\n        code !== null\n        ? ok(code)\n        : nok(code)\n    )\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n */\n\nimport {\n  combineExtensions,\n  combineHtmlExtensions\n} from 'micromark-util-combine-extensions'\nimport {\n  gfmAutolinkLiteral,\n  gfmAutolinkLiteralHtml\n} from 'micromark-extension-gfm-autolink-literal'\nimport {gfmFootnote, gfmFootnoteHtml} from 'micromark-extension-gfm-footnote'\nimport {\n  gfmStrikethrough,\n  gfmStrikethroughHtml\n} from 'micromark-extension-gfm-strikethrough'\nimport {gfmTable, gfmTableHtml} from 'micromark-extension-gfm-table'\nimport {gfmTagfilterHtml} from 'micromark-extension-gfm-tagfilter'\nimport {\n  gfmTaskListItem,\n  gfmTaskListItemHtml\n} from 'micromark-extension-gfm-task-list-item'\n\n/**\n * Support GFM or markdown on github.com.\n *\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfm(options) {\n  return combineExtensions([\n    gfmAutolinkLiteral,\n    gfmFootnote(),\n    gfmStrikethrough(options),\n    gfmTable,\n    gfmTaskListItem\n  ])\n}\n\n/**\n * Support to compile GFM to HTML.\n *\n * @param {HtmlOptions} [options]\n * @returns {HtmlExtension}\n */\nexport function gfmHtml(options) {\n  return combineHtmlExtensions([\n    gfmAutolinkLiteralHtml,\n    gfmFootnoteHtml(options),\n    gfmStrikethroughHtml,\n    gfmTableHtml,\n    gfmTagfilterHtml,\n    gfmTaskListItemHtml\n  ])\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef Options\n *   Configuration (optional).\n * @property {Test} [ignore]\n *   `unist-util-is` test used to assert parents\n *\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {Content|Root} Node\n * @typedef {Exclude<Extract<Node, import('mdast').Parent>, Root>} Parent\n *\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n *\n * @typedef RegExpMatchObject\n * @property {number} index\n * @property {string} input\n * @property {[Root, ...Array<Parent>, Text]} stack\n *\n * @typedef {string|RegExp} Find\n * @typedef {string|ReplaceFunction} Replace\n *\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n * @typedef {Array<Pair>} Pairs\n */\n\n/**\n * @callback ReplaceFunction\n * @param {...any} parameters\n * @returns {Array<PhrasingContent>|PhrasingContent|string|false|undefined|null}\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param tree mdast tree\n * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`\n * @param [replace] Value to insert.\n *   * When `string`, turned into a Text node.\n *   * When `Function`, called with the results of calling `RegExp.exec` as\n *     arguments, in which case it can return a single or a list of `Node`,\n *     a `string` (which is wrapped in a `Text` node), or `false` to not replace\n * @param [options] Configuration.\n */\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &\n   *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)\n   * )}\n   **/\n  (\n    /**\n     * @param {Node} tree\n     * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find\n     * @param {Replace|Options} [replace]\n     * @param {Options} [options]\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options|undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent|undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = /** @type {Parent} */ (parents[index])\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error mdast vs. unist parent.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          // @ts-expect-error: stack is fine.\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @param {[Root, ...Array<Parent>]} parents\n       * @returns {VisitorResult}\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n        /** @type {number|undefined} */\n        let position\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * @param {FindAndReplaceSchema|FindAndReplaceList} schema\n * @returns {Pairs}\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {Find} find\n * @returns {RegExp}\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * @param {Replace} replace\n * @returns {ReplaceFunction}\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown/lib/types.js').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n * @typedef {import('mdast-util-find-and-replace').PhrasingContent} PhrasingContent\n */\n\nimport {ccount} from 'ccount'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\n\nconst inConstruct = 'phrasing'\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/** @type {FromMarkdownExtension} */\nexport const gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n}\n\n/** @type {ToMarkdownExtension} */\nexport const gfmAutolinkLiteralToMarkdown = {\n  unsafe: [\n    {\n      character: '@',\n      before: '[+\\\\-.\\\\w]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {\n      character: '.',\n      before: '[Ww]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {character: ':', before: '[ps]', after: '\\\\/', inConstruct, notInConstruct}\n  ]\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = /** @type {Link} */ (this.stack[this.stack.length - 1])\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {PhrasingContent} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[_-\\d]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string|undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n  /** @type {number} */\n  let closingParenIndex\n  /** @type {number} */\n  let openingParens\n  /** @type {number} */\n  let closingParens\n  /** @type {string|undefined} */\n  let trail\n\n  if (trailExec) {\n    url = url.slice(0, trailExec.index)\n    trail = trailExec[0]\n    closingParenIndex = trail.indexOf(')')\n    openingParens = ccount(url, '(')\n    closingParens = ccount(url, ')')\n\n    while (closingParenIndex !== -1 && openingParens > closingParens) {\n      url += trail.slice(0, closingParenIndex + 1)\n      trail = trail.slice(closingParenIndex + 1)\n      closingParenIndex = trail.indexOf(')')\n      closingParens++\n    }\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n","/**\n * @typedef {import('mdast').Association} Association\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another: controversially,\n * character escapes and references don’t work in this matching: `&copy;` does\n * not match `©`, and `\\+` does not match `+`.\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character escapes\n * and all character references.\n *\n * @param {Association} node\n * @returns {string}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * Functions to track output positions.\n * This info isn’t used yet but suchs functionality allows line wrapping,\n * and theoretically source maps (though, is there practical use in that?).\n *\n * @param {TrackFields} options_\n */\nexport function track(options_) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = options_ || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @returns {{now: Point, lineShift: number}}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @param {number} value\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past a string.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  function move(value = '') {\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Join} Join\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\nimport {track} from './track.js'\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {TrackFields} safeOptions\n * @returns {string}\n */\nexport function containerFlow(parent, context, safeOptions) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  const tracker = track(safeOptions)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      context.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(tracker.move(between(child, children[index + 1])))\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n\n  /**\n   * @param {Node} left\n   * @param {Node} right\n   * @returns {string}\n   */\n  function between(left, right) {\n    let index = context.join.length\n\n    while (index--) {\n      const result = context.join[index](left, right, parent, context)\n\n      if (result === true || result === 1) {\n        break\n      }\n\n      if (typeof result === 'number') {\n        return '\\n'.repeat(1 + result)\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n'\n      }\n    }\n\n    return '\\n\\n'\n  }\n}\n","/**\n * @callback Map\n * @param {string} value\n * @param {number} line\n * @param {boolean} blank\n * @returns {string}\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @param {string} value\n * @param {Map} map\n * @returns {string}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array<string>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<string>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (!list) {\n    return none\n  }\n\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array<string>}} config\n * @returns {string}\n */\nexport function safe(context, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteDefinition(token) {\n    this.enter(\n      {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n      token\n    )\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteDefinitionLabelString() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteDefinitionLabelString(token) {\n    const label = this.resume()\n    const node = /** @type {FootnoteDefinition} */ (\n      this.stack[this.stack.length - 1]\n    )\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteDefinition(token) {\n    this.exit(token)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteCall(token) {\n    this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterFootnoteCallString() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteCallString(token) {\n    const label = this.resume()\n    const node = /** @type {FootnoteDefinition} */ (\n      this.stack[this.stack.length - 1]\n    )\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitFootnoteCall(token) {\n    this.exit(token)\n  }\n}\n\n/**\n * @returns {ToMarkdownExtension}\n */\nexport function gfmFootnoteToMarkdown() {\n  footnoteReference.peek = footnoteReferencePeek\n\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteReference} node\n   */\n  function footnoteReference(node, _, context, safeOptions) {\n    const tracker = track(safeOptions)\n    let value = tracker.move('[^')\n    const exit = context.enter('footnoteReference')\n    const subexit = context.enter('reference')\n    value += tracker.move(\n      safe(context, association(node), {\n        ...tracker.current(),\n        before: value,\n        after: ']'\n      })\n    )\n    subexit()\n    exit()\n    value += tracker.move(']')\n    return value\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function footnoteReferencePeek() {\n    return '['\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n  function footnoteDefinition(node, _, context, safeOptions) {\n    const tracker = track(safeOptions)\n    let value = tracker.move('[^')\n    const exit = context.enter('footnoteDefinition')\n    const subexit = context.enter('label')\n    value += tracker.move(\n      safe(context, association(node), {\n        ...tracker.current(),\n        before: value,\n        after: ']'\n      })\n    )\n    subexit()\n    value += tracker.move(\n      ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n    )\n    tracker.shift(4)\n    value += tracker.move(\n      indentLines(containerFlow(node, context, tracker.current()), map)\n    )\n    exit()\n\n    return value\n\n    /** @type {Map} */\n    function map(line, index, blank) {\n      if (index) {\n        return (blank ? '' : '    ') + line\n      }\n\n      return line\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {track} from './track.js'\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = safeOptions.before\n\n  indexStack.push(-1)\n  let tracker = track(safeOptions)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = context.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = track(safeOptions)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/** @type {FromMarkdownExtension} */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethroughs. So they sort of cancel each other out.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/c47743b/lib/unsafe.js#L11>\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {ToMarkdownExtension} */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\nhandleDelete.peek = peekDelete\n\n/** @type {FromMarkdownHandle} */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('emphasis')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n * @typedef {import('../types.js').Context} Context\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent|undefined} _\n * @param {Context} context\n * @returns {string}\n */\nexport function inlineCode(node, _, context) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef Options\n *   Configuration (optional).\n * @property {string|null|ReadonlyArray<string|null|undefined>} [align]\n *   One style for all columns, or styles for their respective columns.\n *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).\n *   Other values are treated as `''`, which doesn’t place the colon in the\n *   alignment row but does align left.\n *   *Only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean} [padding=true]\n *   Whether to add a space of padding between delimiters and cells.\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {boolean} [delimiterStart=true]\n *   Whether to begin each row with the delimiter.\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean} [delimiterEnd=true]\n *   Whether to end each row with the delimiter.\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean} [alignDelimiters=true]\n *   Whether to align the delimiters.\n *   By default, they are aligned:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {(value: string) => number} [stringLength]\n *   Function to detect the length of table cell content.\n *   This is used when aligning the delimiters (`|`) between table cells.\n *   Full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source.\n *   To fix this, you can pass this function, which receives the cell content\n *   and returns its “visible” size.\n *   Note that what is and isn’t visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['中文', 'Charlie'],\n *     ['👩‍❤️‍👩', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | 中文 | Charlie |\n *   | 👩‍❤️‍👩 | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['中文', 'Charlie'],\n *       ['👩‍❤️‍👩', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | 中文  | Charlie |\n *   | 👩‍❤️‍👩    | Delta   |\n *   ```\n */\n\n/**\n * @typedef {Options} MarkdownTableOptions\n * @todo\n *   Remove next major.\n */\n\n/**\n * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..\n *\n * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table\n *   Table data (matrix of strings).\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n */\nexport function markdownTable(table, options = {}) {\n  const align = (options.align || []).concat()\n  const stringLength = options.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (options.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      options.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (options.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (options.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (options.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        options.padding !== false &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(options.alignDelimiters === false && cell === '') &&\n        (options.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (options.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (options.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (options.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        options.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      options.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string} value\n * @returns {number}\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n    ? 108 /* `l` */\n    : code === 82 /* `R` */ || code === 114 /* `r` */\n    ? 114 /* `r` */\n    : 0\n}\n","/**\n * @typedef {import('mdast').AlignType} AlignType\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n *\n * @typedef Options\n * @property {boolean} [tableCellPadding=true]\n * @property {boolean} [tablePipeAlign=true]\n * @property {MarkdownTableOptions['stringLength']} [stringLength]\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n/** @type {FromMarkdownExtension} */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterTable(token) {\n  /** @type {Array<'left'|'right'|'center'|'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownHandle} */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/** @type {FromMarkdownHandle} */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * @param {Options} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      // @ts-expect-error: fixed in `markdown-table@3.0.1`.\n      node.align\n    )\n  }\n\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    // `markdown-table` will always add an align row\n    const value = serializeData([row])\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string>} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      alignDelimiters,\n      padding,\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../util/indent-lines.js').Map} Map\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\nimport {containerFlow} from '../util/container-flow.js'\nimport {indentLines} from '../util/indent-lines.js'\nimport {track} from '../util/track.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent|undefined} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function listItem(node, parent, context, safeOptions) {\n  const listItemIndent = checkListItemIndent(context)\n  let bullet = context.bulletCurrent || checkBullet(context)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (context.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = track(safeOptions)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = context.enter('listItem')\n  const value = indentLines(\n    containerFlow(node, context, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['listItemIndent'], undefined>}\n */\nexport function checkListItemIndent(context) {\n  const style = context.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bullet'], undefined>}\n */\nexport function checkBullet(context) {\n  const marker = context.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {Extract<import('mdast').Root|import('mdast').Content, import('unist').Parent>} Parent\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').BlockContent} BlockContent\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/** @type {FromMarkdownExtension} */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/** @type {ToMarkdownExtension} */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/** @type {FromMarkdownHandle} */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parent} */ (this.stack[this.stack.length - 2])\n  const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n  const siblings = parent.children\n  const head = node.children[0]\n  let index = -1\n  /** @type {Paragraph|undefined} */\n  let firstParaghraph\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean' &&\n    head &&\n    head.type === 'text'\n  ) {\n    while (++index < siblings.length) {\n      const sibling = siblings[index]\n      if (sibling.type === 'paragraph') {\n        firstParaghraph = sibling\n        break\n      }\n    }\n\n    if (firstParaghraph === node) {\n      // Must start with a space or a tab.\n      head.value = head.value.slice(1)\n\n      if (head.value.length === 0) {\n        node.children.shift()\n      } else if (\n        node.position &&\n        head.position &&\n        typeof head.position.start.offset === 'number'\n      ) {\n        head.position.start.column++\n        head.position.start.offset++\n        node.position.start = Object.assign({}, head.position.start)\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-gfm-table').Options} Options\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * @returns {Array<FromMarkdownExtension>}\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * @param {Options} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {string} Type\n * @typedef {Object<string, unknown>} Props\n *\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\n */\n\n/**\n * Check if a node passes a test\n *\n * @callback TestFunctionAnything\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} X\n * @callback TestFunctionPredicate\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is X}\n */\n\n/**\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\n\nexport const is =\n  /**\n   * Check if a node passes a test.\n   * When a `parent` node is known the `index` of node should also be given.\n   *\n   * @type {(\n   *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\n   *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * Check if a node passes a test.\n     * When a `parent` node is known the `index` of node should also be given.\n     *\n     * @param {unknown} [node] Node to check\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @param {number|null|undefined} [index] Position of `node` in `parent`\n     * @param {Parent|null|undefined} [parent] Parent of `node`\n     * @param {unknown} [context] Context object to invoke `test` with\n     * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\nexport const convert =\n  /**\n   * @type {(\n   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * Generate an assertion from a check.\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n/**\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Utility to assert each property in `test` is represented in `node`, and each\n * values are strictly equal.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given node’s type\n * for said string.\n *\n * @param {Type} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given node’s type\n * for said string.\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(...parameters) {\n    // @ts-expect-error: spreading is fine.\n    return Boolean(check.call(this, ...parameters))\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('./complex-types.js').Action} Action\n * @typedef {import('./complex-types.js').Index} Index\n * @typedef {import('./complex-types.js').ActionTuple} ActionTuple\n * @typedef {import('./complex-types.js').VisitorResult} VisitorResult\n * @typedef {import('./complex-types.js').Visitor} Visitor\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = true\n/**\n * Do not traverse this node’s children\n */\nexport const SKIP = 'skip'\n/**\n * Stop traversing immediately\n */\nexport const EXIT = false\n\n/**\n * Visit children of tree which pass test.\n *\n * @param tree\n *   Tree to walk\n * @param [test]\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Function called for nodes that pass `test`.\n * @param [reverse=false]\n *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types.js').Visitor<Node>} visitor\n     * @param {boolean} [reverse=false]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, null, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number?} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = typeof node === 'object' && node !== null ? node : {}\n        /** @type {string|undefined} */\n        let name\n\n        if (typeof value.type === 'string') {\n          name =\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' +\n              color(value.type + (name ? '<' + name + '>' : '')) +\n              ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n"],"names":["element","document","createElement","decodeNamedCharacterReference","value","characterReference","innerHTML","char","textContent","charCodeAt","length","blankLine","tokenize","effects","ok","nok","factorySpace","code","markdownLineEnding","partial","type","max","limit","Number","POSITIVE_INFINITY","size","markdownSpace","enter","prefix","consume","exit","asciiAlpha","regexCheck","asciiDigit","asciiHexDigit","asciiAlphanumeric","asciiPunctuation","asciiAtext","asciiControl","markdownLineEndingOrSpace","unicodeWhitespace","unicodePunctuation","regex","test","String","fromCharCode","splice","list","start","remove","items","parameters","end","chunkStart","Array","from","unshift","apply","slice","push","classifyCharacter","hasOwnProperty","combineExtensions","extensions","all","index","syntaxExtension","extension","hook","left","call","undefined","right","constructs","isArray","existing","before","add","decodeNumericCharacterReference","base","parseInt","characterEscapeOrReference","decodeString","replace","decode","$0","$1","$2","head","hex","normalizeIdentifier","toLowerCase","toUpperCase","resolveAll","events","context","called","resolve","includes","www","w2","w3","dot","after","domain","hasUnderscoreInLastSegment","hasUnderscoreInLastLastSegment","check","namedCharacterReference","done","punctuationContinuation","punctuation","path","balance","inPath","continuedPunctuation","parenAtPathEnd","pathEnd","trailingPunctuation","inside","wwwAutolink","self","this","previousWww","previous","previousUnbalanced","attempt","httpAutolink","previousHttp","t1","t2","p","s","colon","slash1","slash2","emailAutolink","hasDot","hasDigitInLastSegment","gfmAtext","previousEmail","atext","label","dotContinuation","dashOrUnderscoreContinuation","afterDashOrUnderscore","text","gfmAutolinkLiteral","result","token","_balanced","_gfmAutolinkLiteralWalkedInto","indent","tail","sliceSerialize","gfmFootnote","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","gfmFootnoteDefinitionEnd","tokenizeGfmFootnoteCall","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","labelStart","defined","parser","gfmFootnotes","id","now","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","data","callStart","callData","callEscape","identifier","_container","atBreak","labelAfter","labelEscape","gfmStrikethrough","options","single","singleTilde","tokenizer","tokenizeStrikethrough","resolveAllStrikethrough","insideSpan","null","attentionMarkers","_close","open","_open","strikethrough","nextEvents","more","Boolean","gfmTable","flow","seenDelimiter","hasDash","align","tableHeaderCount","_align","cellDividerHead","inCellContentHead","cellBreakHead","originalInterrupt","interrupt","tokenizeRowEnd","atDelimiterRowBreak","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","rowEndDelimiter","inWhitespaceDelimiter","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","nextPrefixedOrBlank","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","tableBodyClose","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","prefixed","lazy","line","disable","_gfmTableDynamicInterruptHack","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","content","cell","whitespace","tasklistCheck","_gfmTasklistFirstContentOfListItem","close","spaceThenNonSpace","gfmTaskListItem","gfm","ccount","character","source","TypeError","count","indexOf","own","findAndReplace","tree","find","settings","schema","RegExp","ignored","convert","ignore","pairs","toExpression","toFunction","key","toPairs","pairIndex","visitParents","visitor","node","parents","grandparent","parent","children","position","change","nodes","lastIndex","match","exec","matchObject","input","stack","global","handler","escape","inConstruct","notInConstruct","gfmAutolinkLiteralFromMarkdown","transforms","findUrl","findEmail","literalAutolink","title","url","literalAutolinkEmail","enterLiteralAutolinkValue","literalAutolinkHttp","literalAutolinkWww","config","autolinkEmail","autolinkProtocol","gfmAutolinkLiteralToMarkdown","unsafe","_","protocol","parts","split","isCorrectDomain","closingParenIndex","openingParens","closingParens","trail","trailExec","splitUrl","email","association","track","options_","lineShift","move","chunks","current","shift","containerFlow","safeOptions","indexStack","tracker","results","child","handle","bulletLastUsed","between","pop","join","repeat","eol","indentLines","map","one","patternCompile","pattern","_compiled","patternInScope","listInScope","none","safe","positions","infos","expression","sort","numerical","escapeBackslashes","charAt","encode","toString","a","b","whole","gfmFootnoteToMarkdown","footnoteReference","peek","handlers","footnoteDefinition","subexit","blank","containerPhrasing","gfmStrikethroughFromMarkdown","canContainEols","gfmStrikethroughToMarkdown","delete","handleDelete","inlineCode","sequence","serialize","defaultStringLength","toAlignment","codePointAt","gfmTableFromMarkdown","table","d","setData","tableData","enterCell","tableHeader","tableRow","codeText","resume","getData","gfmTableToMarkdown","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","serializeData","handleTableRowAsData","handleTableAsData","tableCell","handleTableCell","matrix","concat","alignments","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","rowIndex","row","sizes","columnIndex","Math","lines","delimiterStart","delimiterEnd","markdownTable","listItem","listItemIndent","style","Error","checkListItemIndent","bullet","bulletCurrent","checkBullet","ordered","incrementListMarker","spread","ceil","gfmTaskListItemFromMarkdown","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","firstParaghraph","siblings","checked","sibling","gfmTaskListItemToMarkdown","checkable","checkbox","gfmFromMarkdown","gfmFootnoteDefinition","gfmFootnoteDefinitionLabelString","buffer","gfmFootnoteCall","gfmFootnoteCallString","gfmToMarkdown","remarkGfm","field","castFactory","typeFactory","anyFactory","propsFactory","tests","checks","reverse","is","step","factory","name","tagName","defineProperty","visit","subresult","grandparents","toResult"],"sourceRoot":""}